import express from "express";
import axios from "axios";
import * as fuzz from "fuzzball";
import { manager, SCENES, initNLU, normalize } from "../nluManager.js";
import Image from "../models/Image.js";
import { SYNONYMS } from "../models/synonyms.js";

const router = express.Router();

const HUGGING_FACE_API_KEY = process.env.HUGGING_FACE_API_KEY;
const LLM_MODEL = "openai/gpt-oss-20b:groq";
const HUGGING_FACE_API_URL = "https://router.huggingface.co/v1/chat/completions";

/* ============================================================
 üîπ 1) Fonction : Appeler Hugging Face en utilisant l‚Äôannotation
=============================================================== */
async function queryLLM(userMessage, currentSceneTitle, annotation) {
  if (!HUGGING_FACE_API_KEY) return "Erreur : Cl√© Hugging Face manquante.";

  const systemPrompt = `
Tu es un guide virtuel dans une visite virtuelle interactive dans l'ENSAM Meknes Maroc.
Tu dois aider l‚Äôutilisateur en utilisant les donn√©es suivantes :

=== DONN√âES DE LA SC√àNE "${currentSceneTitle}" ===
Information : ${annotation?.information || "Aucune information"}
Objets :
${annotation?.objects?.length ? annotation.objects.map(o => `- ${o.label} : ${o.description}`).join("\n") : "Aucun objet"}
Directions :
${annotation?.related_scenes ? Object.entries(annotation.related_scenes).map(([dir, title]) => `- ${dir} ‚Üí ${title}`).join("\n") : "Aucune direction"}
===================================================

R√àGLES IMPORTANTES :
1. Utilise **en priorit√©** les donn√©es ci-dessus.
2. Si ces donn√©es ne suffisent pas, compl√®te avec tes connaissances.
3. R√©pond toujours avec la meme langue de la questions et de fa√ßon courte.
`;

  try {
    const response = await axios.post(
      HUGGING_FACE_API_URL,
      {
        model: LLM_MODEL,
        messages: [
          { role: "system", content: systemPrompt },
          { role: "user", content: userMessage }
        ],
      },
      {
        headers: {
          Authorization: `Bearer ${HUGGING_FACE_API_KEY}`,
          "Content-Type": "application/json",
        },
      }
    );

    return response.data.choices?.[0]?.message?.content || "Pas de r√©ponse du mod√®le.";
  } catch (err) {
    console.error("Erreur LLM HF :", err.response?.data || err.message);
    return "Erreur lors de la g√©n√©ration de la r√©ponse.";
  }
}

/* ====================================================
 üîπ 2) Fonction principale de traitement du message
===================================================== */
async function processChatRequest(message, currentSceneId) {
  const currentSceneTitle = SCENES[currentSceneId]?.title || "Lieu inconnu";

  const nluResult = await manager.process("fr", message);
  const intent = nluResult.intent;
  const confidence = nluResult.score;

  /* ----------------------------------------------- */
  /* üîπ D√©tection d‚Äôun lieu dans le message          */
  /* ----------------------------------------------- */

  let targetTitle = null;
  const targetEntity = nluResult.entities.find(e => e.entity === "lieu");

  if (targetEntity?.option) {
    targetTitle = SYNONYMS[targetEntity.option.toLowerCase()] || targetEntity.option;
  } else {
    const normalizedMessage = normalize(message);

    const synKey = Object.keys(SYNONYMS).find(k =>
      normalizedMessage.includes(normalize(k))
    );

    if (synKey) {
      targetTitle = SYNONYMS[synKey];
    } else {
      const allTitles = Object.values(SCENES).map(s => normalize(s.title));
      const result = fuzz.extract(normalizedMessage, allTitles, {
        scorer: fuzz.ratio,
        returnObjects: true
      });

      if (result.length > 0 && result[0].score > 60) {
        targetTitle =
          Object.values(SCENES).find(s => normalize(s.title) === result[0].choice)?.title;
      }
    }
  }

  const targetSceneId = targetTitle
    ? Object.keys(SCENES).find(id => SCENES[id].title === targetTitle)
    : null;

  /* ----------------------------------------------- */
  /* üîπ Navigation entre sc√®nes                      */
  /* ----------------------------------------------- */
  if (intent === "navigation.goto") {
    if (!targetSceneId)
      return { reply: `Lieu inconnu : ${targetTitle || "demand√©"}` };

    if (targetSceneId === currentSceneId)
      return { reply: `‚ú® Vous √™tes d√©j√† dans : **${SCENES[targetSceneId].title}**` };

    return {
      reply: null,
      command: { type: "loadScene", sceneId: targetSceneId }
    };
  }

  /* ----------------------------------------------- */
  /* üîπ Informations sur une sc√®ne                   */
  /* ----------------------------------------------- */
  if (intent.startsWith("info.")) {
    const infoSceneId = ["info.describe_current", "info.whereami"].includes(intent)
      ? currentSceneId
      : targetSceneId;

    const scene = await Image.findOne({ id_image: infoSceneId });

    if (!scene?.annotation)
      return { reply: "Aucune annotation trouv√©e." };

    const { related_scenes, objects, information } = scene.annotation;

    let result = "";

    if (information) result += information + "\n\n";

    if (objects?.length) {
      result += "üìå **Objets importants ici :**\n";
      objects.forEach(obj => {
        result += `- **${obj.label}** : ${obj.description}\n`;
      });
    }

    if (related_scenes) {
      result += "\n‚û°Ô∏è **Directions disponibles :**\n";
      for (const dir in related_scenes) {
        result += `- **${dir}** : ${related_scenes[dir]}\n`;
      }
    }

    return { reply: result.trim() };
  }

  /* ----------------------------------------------- */
  /* üîπ Fallback : LLM r√©pond en se basant sur l‚Äôannotation */
  /* ----------------------------------------------- */
  if (confidence < 0.5 || intent === "None") {
    const scene = await Image.findOne({ id_image: currentSceneId });

    const llmReply = await queryLLM(
      message,
      currentSceneTitle,
      scene?.annotation || {}
    );

    return { reply: llmReply };
  }

  return { reply: "Je peux vous aider √† naviguer ou d√©crire des lieux !" };
}

/* ====================================================
 üîπ 3) Route POST /chat
===================================================== */
router.post("/", async (req, res) => {
  const { message, currentSceneId } = req.body;

  if (!message || !currentSceneId)
    return res.status(400).json({ reply: "Message et currentSceneId requis." });

  try {
    const response = await processChatRequest(message, currentSceneId);
    res.json(response);
  } catch (err) {
    console.error("Erreur Chatbot :", err);
    res.status(500).json({ reply: "Erreur interne du serveur." });
  }
});

initNLU();
export default router;
